//! Functions concerned with extracting known values from kwargs

use crate::utility::caller::src_caller_meta;
use origen_metal::prog_gen::{flow_api, FlowCondition, FlowID};
use origen::Result;
use pyo3::types::PyDict;

pub fn is_flow_option(key: &str) -> bool {
    match key {
        "id" => true,
        "bin" => true,
        "softbin" => true,
        "soft_bin" => true,
        "if_enable" => true,
        "if_enabled" => true,
        "unless_enable" => true,
        "unless_enabled" => true,
        "if_job" => true,
        "unless_job" => true,
        "if_ran" => true,
        "unless_ran" => true,
        "if_passed" => true,
        "unless_passed" => true,
        "if_failed" => true,
        "unless_failed" => true,
        "if_flag" => true,
        "unless_flag" => true,
        _ => false,
    }
}

/// Wraps everything generated by the given code block in any flow condition options (e.g.
/// if_failed, if_enabled, etc.) that are specified in the given kwargs.
/// If left open a vector of reference IDs will be returned and the user should call flow_api::end_block on them
/// when they are ready to close the condition block.
pub fn wrap_in_conditions<T, F>(
    kwargs: Option<&PyDict>,
    leave_open: bool,
    func: F,
) -> Result<(T, Option<Vec<usize>>)>
where
    F: FnOnce() -> Result<T>,
{
    if let Some(kwargs) = kwargs {
        let mut ref_ids = vec![];
        if let Some(ids) = extract_condition("if_enable", kwargs)? {
            ref_ids.push(flow_api::start_condition(
                FlowCondition::IfEnable(ids),
                src_caller_meta(),
            )?);
        }
        if let Some(ids) = extract_condition("if_enabled", kwargs)? {
            ref_ids.push(flow_api::start_condition(
                FlowCondition::IfEnable(ids),
                src_caller_meta(),
            )?);
        }
        if let Some(ids) = extract_condition("unless_enable", kwargs)? {
            ref_ids.push(flow_api::start_condition(
                FlowCondition::UnlessEnable(ids),
                src_caller_meta(),
            )?);
        }
        if let Some(ids) = extract_condition("unless_enabled", kwargs)? {
            ref_ids.push(flow_api::start_condition(
                FlowCondition::UnlessEnable(ids),
                src_caller_meta(),
            )?);
        }
        if let Some(ids) = extract_condition("if_job", kwargs)? {
            ref_ids.push(flow_api::start_condition(
                FlowCondition::IfJob(ids),
                src_caller_meta(),
            )?);
        }
        if let Some(ids) = extract_condition("unless_job", kwargs)? {
            ref_ids.push(flow_api::start_condition(
                FlowCondition::UnlessJob(ids),
                src_caller_meta(),
            )?);
        }
        if let Some(ids) = extract_condition("if_ran", kwargs)? {
            ref_ids.push(flow_api::start_condition(
                FlowCondition::IfRan(ids.iter().map(|id| FlowID::from_str(id)).collect()),
                src_caller_meta(),
            )?);
        }
        if let Some(ids) = extract_condition("unless_ran", kwargs)? {
            ref_ids.push(flow_api::start_condition(
                FlowCondition::UnlessRan(ids.iter().map(|id| FlowID::from_str(id)).collect()),
                src_caller_meta(),
            )?);
        }
        if let Some(ids) = extract_condition("if_passed", kwargs)? {
            ref_ids.push(flow_api::start_condition(
                FlowCondition::IfPassed(ids.iter().map(|id| FlowID::from_str(id)).collect()),
                src_caller_meta(),
            )?);
        }
        if let Some(ids) = extract_condition("unless_passed", kwargs)? {
            ref_ids.push(flow_api::start_condition(
                FlowCondition::IfFailed(ids.iter().map(|id| FlowID::from_str(id)).collect()),
                src_caller_meta(),
            )?);
        }
        if let Some(ids) = extract_condition("if_failed", kwargs)? {
            ref_ids.push(flow_api::start_condition(
                FlowCondition::IfFailed(ids.iter().map(|id| FlowID::from_str(id)).collect()),
                src_caller_meta(),
            )?);
        }
        if let Some(ids) = extract_condition("unless_failed", kwargs)? {
            ref_ids.push(flow_api::start_condition(
                FlowCondition::IfPassed(ids.iter().map(|id| FlowID::from_str(id)).collect()),
                src_caller_meta(),
            )?);
        }
        if let Some(ids) = extract_condition("if_flag", kwargs)? {
            ref_ids.push(flow_api::start_condition(
                FlowCondition::IfFlag(ids),
                src_caller_meta(),
            )?);
        }
        if let Some(ids) = extract_condition("unless_flag", kwargs)? {
            ref_ids.push(flow_api::start_condition(
                FlowCondition::UnlessFlag(ids),
                src_caller_meta(),
            )?);
        }
        let r = func()?;
        ref_ids.reverse();
        if leave_open {
            Ok((r, Some(ref_ids)))
        } else {
            for id in ref_ids {
                flow_api::end_block(id)?;
            }
            Ok((r, None))
        }
    } else {
        Ok((func()?, None))
    }
}

fn extract_condition(name: &str, kwargs: &PyDict) -> Result<Option<Vec<String>>> {
    if let Some(v) = kwargs.get_item(name) {
        if let Ok(v) = v.extract::<String>() {
            Ok(Some(vec![v]))
        } else if let Ok(v) = v.extract::<Vec<String>>() {
            Ok(Some(v))
        } else {
            bail!(
                "Illegal '{}' value, expected a String or a List of Strings, got: '{}'",
                name,
                v
            )
        }
    } else {
        Ok(None)
    }
}

/// Returns a FlowID object from an "id" field present in the args, or else
/// a generated ID.
pub fn get_flow_id(kwargs: Option<&PyDict>) -> Result<FlowID> {
    if let Some(kwargs) = kwargs {
        if let Some(id) = kwargs.get_item("id") {
            if let Ok(v) = id.extract::<String>() {
                return Ok(FlowID::from_str(&v));
            } else if let Ok(v) = id.extract::<usize>() {
                return Ok(FlowID::from_int(v));
            } else {
                bail!(
                    "Illegal 'id' value, expected a String or an Integer, got: '{}'",
                    id
                );
            }
        }
    }
    Ok(FlowID::new())
}

pub fn get_bin(kwargs: Option<&PyDict>) -> Result<Option<usize>> {
    if let Some(kwargs) = kwargs {
        if let Some(bin) = kwargs.get_item("bin") {
            if let Ok(v) = bin.extract::<usize>() {
                return Ok(Some(v));
            } else {
                bail!("Illegal 'bin' value, expected an Integer, got: '{}'", bin);
            }
        }
    }
    Ok(None)
}

pub fn get_softbin(kwargs: Option<&PyDict>) -> Result<Option<usize>> {
    if let Some(kwargs) = kwargs {
        if let Some(bin) = kwargs.get_item("softbin") {
            if let Ok(v) = bin.extract::<usize>() {
                return Ok(Some(v));
            } else {
                bail!(
                    "Illegal 'softbin' value, expected an Integer, got: '{}'",
                    bin
                );
            }
        }
        if let Some(bin) = kwargs.get_item("soft_bin") {
            if let Ok(v) = bin.extract::<usize>() {
                return Ok(Some(v));
            } else {
                bail!(
                    "Illegal 'soft_bin' value, expected an Integer, got: '{}'",
                    bin
                );
            }
        }
    }
    Ok(None)
}

pub fn on_fail(fid: &FlowID, kwargs: Option<&PyDict>) -> Result<()> {
    if let Some(kwargs) = kwargs {
        let cont =
            kwargs.get_item("continue").is_some() || kwargs.get_item("continue_on_fail").is_some();
        if let Some(on_fail) = kwargs.get_item("on_fail") {
            let ref_id = flow_api::start_on_failed(fid.to_owned(), None)?;
            if cont {
                flow_api::continue_on_fail(None)?;
            }
            if let Ok(on_fail) = on_fail.downcast::<PyDict>() {
                for (k, v) in on_fail {
                    if let Ok(k) = k.extract::<String>() {
                        match k.as_str() {
                            "set_flag" => {
                                if let Ok(v) = v.extract::<String>() {
                                    flow_api::set_flag(v, true, src_caller_meta())?;
                                } else {
                                    bail!(
                                        "Illegal value for set_flag, expected a String, got: '{}'",
                                        v
                                    );
                                }
                            }
                            _ => {
                                bail!("Illegal key in 'on_fail' Dict '{}'", k);
                            }
                        }
                    } else {
                        bail!(
                            "Illegal key in 'on_fail' Dict, expected a String, got: '{}'",
                            k
                        );
                    }
                }
            } else {
                bail!(
                    "Illegal 'on_fail' value, expected a Dict, got: '{}'",
                    on_fail
                );
            }
            flow_api::end_block(ref_id)?;
        } else if cont {
            let ref_id = flow_api::start_on_failed(fid.to_owned(), None)?;
            flow_api::continue_on_fail(None)?;
            flow_api::end_block(ref_id)?;
        }
    }
    Ok(())
}

pub fn on_pass(fid: &FlowID, kwargs: Option<&PyDict>) -> Result<()> {
    if let Some(kwargs) = kwargs {
        if let Some(on_pass) = kwargs.get_item("on_pass") {
            let ref_id = flow_api::start_on_failed(fid.to_owned(), None)?;
            if let Ok(on_pass) = on_pass.downcast::<PyDict>() {
                for (k, v) in on_pass {
                    if let Ok(k) = k.extract::<String>() {
                        match k.as_str() {
                            "set_flag" => {
                                if let Ok(v) = v.extract::<String>() {
                                    flow_api::set_flag(v, true, src_caller_meta())?;
                                } else {
                                    bail!(
                                        "Illegal value for set_flag, expected a String, got: '{}'",
                                        v
                                    );
                                }
                            }
                            _ => {
                                bail!("Illegal key in 'on_pass' Dict '{}'", k);
                            }
                        }
                    } else {
                        bail!(
                            "Illegal key in 'on_pass' Dict, expected a String, got: '{}'",
                            k
                        );
                    }
                }
            } else {
                bail!(
                    "Illegal 'on_pass' value, expected a Dict, got: '{}'",
                    on_pass
                );
            }
            flow_api::end_block(ref_id)?;
        }
    }
    Ok(())
}
